using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.UI;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
// The code generated by `dotnet dbus codegen`.
using bluez.DBus;
using PearlSoft.Scripts.Runtime.ScreenUI.OutputElements;
// See https://developers.redhat.com/blog/2017/09/18/connecting-net-core-d-bus/ or https://github.com/tmds/Tmds.DBus
using Tmds.DBus;
using Debug = UnityEngine.Debug;


public class BluetoothConsole : MonoBehaviour
{

    [SerializeField]
    private MonospaceTextLogOutput _console;

    [SerializeField]
    private Transform _rotateCube;

    [SerializeField]
    private Text _voltageText;

    private bool _sensorEnabled = true;

    private string _boardSelection = "A";

    private bool _isConnected = false;

    private bool _connectionAttemptActive = false;

    public bool IsConnected
    {
        get { return _isConnected; }
    }


    private IEnumerator Start()
    {
        while (InputManager.I == null)
        {
            yield return null;
        }

        while (HeartbeatController.I == null)
        {
            yield return null;
        }

        _boardSelection = PlayerPrefs.GetString("boardSelection", "A");

        _console.LogText($"Scan Started, Board {_boardSelection}");

        Scan();

        UpdateButtonText();
    }

    public void ToggleSensor()
    {
        _sensorEnabled = !_sensorEnabled;

        UpdateButtonText();
    }

    private void UpdateButtonText()
    {
    }

    private void Update()
    {
        if (!_isConnected && !_connectionAttemptActive)
        {
            _console.LogText($"Autoreconnect");
            Scan();
        }
    }

    public void SetToBoardA()
    {
        _boardSelection = "A";
        PlayerPrefs.SetString("boardSelection", "A");
        _console.LogText($"Selected {_boardSelection}");
    }

    public void SetToBoardB()
    {
        _boardSelection = "B";
        PlayerPrefs.SetString("boardSelection", "B");
        _console.LogText($"Selected {_boardSelection}");
    }

    public void SetToBoardC()
    {
        _boardSelection = "C";
        PlayerPrefs.SetString("boardSelection", "C");
        _console.LogText($"Selected {_boardSelection}");
    }
    

    public void Scan()
    {
        _connectionAttemptActive = true;
        var adapterName = "hci0";

        var adapterObjectPath = $"/org/bluez/{adapterName}";
        var adapter = Connection.System.CreateProxy<IAdapter1>(BluezConstants.DBusService, adapterObjectPath);

        if (adapter == null)
        {
            _console.LogText(($"Adapter Missing"));
        }
        else
        {
            _console.LogText("Adapter found");
        }

        ScanAsync(adapter);

        // Find the Bluetooth peripheral.


    }

    private async void ScanAsync(IAdapter1 adapter)
    {
        var deviceAddressA = "58:CF:79:F3:29:BE";
        var deviceAddressB = "58:CF:79:F1:FD:46";
        var deviceAddressC = "58:CF:79:EA:CE:FE";

        //var device = await adapter.GetDeviceAsyncAnyByName("DataCollector_");

        var selectedDeviceAddress = deviceAddressA;

        switch (_boardSelection)
        {
            case "A":
                selectedDeviceAddress = deviceAddressA;
                break;
            case "B":
                selectedDeviceAddress = deviceAddressB;
                break;
            case "C":
                selectedDeviceAddress = deviceAddressC;
                break;
        }

        var device = await adapter.GetDeviceAsync(selectedDeviceAddress);

        if (device == null)
        {
            _console.LogText(
                $"BLE Robot missing");
            _connectionAttemptActive = false;
            return;
        }

        _console.LogText($"BLE Robot found");

        var isConnected = await device.GetConnectedAsync();

        if (isConnected == false)
        {
            _console.LogText(("Not connected"));
            _console.LogText(("Connecting..."));
            await device.ConnectAsync();
        }
        
        //await WaitForPropertyValueAsync<bool>("Connected", device.GetConnectedAsync(), value: true, 5);
        _console.LogText(($"Connected to {_boardSelection}"));


        var servicesUUID = await device.GetUUIDsAsync();
        _console.LogText(($"{servicesUUID.Length} service(s)"));

        var deviceInfoServiceFound = servicesUUID.Any(uuid => String.Equals(uuid, GattConstants.DeviceInformationServiceUUID, StringComparison.OrdinalIgnoreCase));

        if (!deviceInfoServiceFound)
        {
            _console.LogText(("Missing DIS"));
            _connectionAttemptActive = false;
            return;
        }

        var service = await device.GetServiceAsync(GattConstants.DeviceInformationServiceUUID);

        var orientationAllCharacteristic = await service.GetCharacteristicAsync(GattConstants.OrientationAllUUID);
        var ctrlAllCharacteristic = await service.GetCharacteristicAsync(GattConstants.CtrlAllUUID);


        byte[] orientationAll;
        int characteristicsFound = 0;

        var timeout = TimeSpan.FromSeconds(5);

        if (orientationAllCharacteristic != null)
        {
            characteristicsFound++;
            _console.LogText(("Get Telemetry"));
        }

        int defaultAngle = 90;

        if (ctrlAllCharacteristic != null)
        {
            characteristicsFound++;
            _console.LogText(("Set Control"));
        }

        if (characteristicsFound == 0)
        {
            _console.LogText(("No GATTChar found"));
        }

        _console.LogText("Initialized");
        _isConnected = true;
        _connectionAttemptActive = false;
        
        var taskS = JoystickTask(ctrlAllCharacteristic, device);
        var taskAll = SensorAllTask(orientationAllCharacteristic, device);
        await Task.WhenAll(taskS, taskAll);


    }

    private async Task JoystickTask(IGattCharacteristic1 characteristicAll, IDevice1 device)
    {
        var timeout = TimeSpan.FromSeconds(5);
        short lValue;
        short rValue;

        var lastTimeReadSensors = Time.time;
        var readCooldown = 0.05f;

        while (Application.isPlaying)
        {

            while (Time.time < (lastTimeReadSensors + readCooldown))
            {
                await Task.Delay(10);
            }

            var connectedStatus = await device.GetConnectedAsync();

            if (!connectedStatus)
            {
                Debug.LogError("Connection to bot lost! (on write)");
                _console.LogText(("Connection lost"));
                _isConnected = false;
                break;
            }

            lastTimeReadSensors = Time.time;

            short safetyOffset = 0;

            const short amountToThrottle = 30;
            const short forwardAngle = 90 + amountToThrottle;
            const short reverseAngle = 90 - amountToThrottle;

            if (InputManager.I.DPadUpPressed)
            {
                lValue = forwardAngle;
                rValue = forwardAngle;
            }
            else if (InputManager.I.DPadDownPressed)
            {
                lValue = reverseAngle;
                rValue = reverseAngle;
            }
            else if (InputManager.I.DPadLeftPressed)
            {
                lValue = reverseAngle;
                rValue = forwardAngle;
            }
            else if (InputManager.I.DPadRightPressed)
            {
                lValue = forwardAngle;
                rValue = reverseAngle;
            }
            else
            {
                lValue = (short) ((short) (InputManager.I.LY * -90f + 90f));
                rValue = (short) ((short) (InputManager.I.RY * -90f + 90f));

            }

            short w0Value = (short) ((short) (InputManager.I.L2 * -90f + 90f));
            short w1Value = (short) ((short) (InputManager.I.R2 * -90f + 90f));

            if (InputManager.I.R1)
            {
                w1Value = 180;
            }
            


            TelemetryValues.I.WeaponThrottle = w1Value;
            
            Debug.LogError($"InputManager.I.L2: {InputManager.I.L2}, r1 pressed? {InputManager.I.R1}, w1 value: {w1Value}" );

            short driveThrottle = (short) (-InputManager.I.LY * 100);

            short SecurityBytes = 0x69;

            short placeholderBytes = 0x00;

            List<byte> ctrlValueList = new List<byte>();
            ctrlValueList.AddRange(BitConverter.GetBytes(SecurityBytes)); //0-1
            ctrlValueList.AddRange(BitConverter.GetBytes(InputManager.I.ButtonBytes)); //2-3
            ctrlValueList.AddRange(BitConverter.GetBytes(InputManager.I.Heading)); //4-5
            ctrlValueList.AddRange(BitConverter.GetBytes(driveThrottle)); //6-7
            ctrlValueList.AddRange(BitConverter.GetBytes(lValue)); //8-9
            ctrlValueList.AddRange(BitConverter.GetBytes(rValue)); //10-11
            ctrlValueList.AddRange(BitConverter.GetBytes(w0Value)); //12-13
            ctrlValueList.AddRange(BitConverter.GetBytes(w1Value)); //14-15
            //ctrlValueList.AddRange(BitConverter.GetBytes(placeholderBytes)); //16
            //ctrlValueList.AddRange(BitConverter.GetBytes(placeholderBytes)); //18

            ctrlValueList.Add(SoftValuesManager.NormalizedFloatToByte(SoftValuesManager.I.AngleToleranceNormalized)); //16
            ctrlValueList.Add(SoftValuesManager.NormalizedFloatToByte(SoftValuesManager.I.TurningMultiplierNormalized)); //17
            ctrlValueList.Add(SoftValuesManager.NormalizedFloatToByte(SoftValuesManager.I.AdditiveThrottleMultiplerNormalized)); //18
            ctrlValueList.Add(SoftValuesManager.NormalizedFloatToByte(SoftValuesManager.I.MaxWeaponThrottleNormalized)); //19


            ctrlValueList.AddRange(BitConverter.GetBytes(placeholderBytes)); //20
            ctrlValueList.AddRange(BitConverter.GetBytes(placeholderBytes)); //22
            ctrlValueList.AddRange(BitConverter.GetBytes(placeholderBytes)); //24
            ctrlValueList.AddRange(BitConverter.GetBytes(placeholderBytes)); //26
            ctrlValueList.AddRange(BitConverter.GetBytes(placeholderBytes)); //28
            ctrlValueList.AddRange(BitConverter.GetBytes(placeholderBytes)); //30
            ctrlValueList.AddRange(BitConverter.GetBytes(HeartbeatController.I.HeartbeatTime)); // 32-35
            ctrlValueList.AddRange(BitConverter.GetBytes(SecurityBytes)); //36-37

            byte[] ctrlValue = ctrlValueList.ToArray();


            var writeAll = characteristicAll.WriteValueAsync(ctrlValue, timeout);

            await Task.WhenAll(writeAll);

            //Debug.LogError($"joystick task {Time.time:0.000}");
        }
    }

    private async Task SensorAllTask(IGattCharacteristic1 characteristicAll, IDevice1 device)
    {
        var timeout = TimeSpan.FromSeconds(5);

        var lastTimeReadSensors = Time.time;
        var readCooldown = 0.05f;

        while (Application.isPlaying)
        {

            //Debug.LogError($"sensor task {Time.time:0.000}");

            while (Time.time < (lastTimeReadSensors + readCooldown))
            {
                await Task.Delay(10);
            }

            var connectedStatus = await device.GetConnectedAsync();

            if (!connectedStatus)
            {
                Debug.LogError("Connection to bot lost! (on read)");
                _console.LogText(("Connection lost"));
                _isConnected = true;
                break;
            }

            lastTimeReadSensors = Time.time;

            byte[] orientationAll;
            orientationAll = await characteristicAll.ReadValueAsync(timeout);

            byte[] voltageBytes = {orientationAll[0], orientationAll[1]};

            byte[] orientationRBytes = {orientationAll[2], orientationAll[3], orientationAll[4], orientationAll[5]};
            byte[] orientationIBytes = {orientationAll[6], orientationAll[7], orientationAll[8], orientationAll[9]};
            byte[] orientationJBytes = {orientationAll[10], orientationAll[11], orientationAll[12], orientationAll[13]};
            byte[] orientationKBytes = {orientationAll[14], orientationAll[15], orientationAll[16], orientationAll[17]};

            byte[] bnoAccelerationXBytes = {orientationAll[18], orientationAll[19]};
            byte[] bnoAccelerationYBytes = {orientationAll[20], orientationAll[21]};
            byte[] bnoAccelerationZBytes = {orientationAll[22], orientationAll[23]};

            byte[] lisAccelerationXBytes = {orientationAll[24], orientationAll[25]};
            byte[] lisAccelerationYBytes = {orientationAll[26], orientationAll[27]};
            byte[] lisAccelerationZBytes = {orientationAll[28], orientationAll[29]};

            byte[] escTemperatureBytes = {orientationAll[30], orientationAll[31]};
            byte[] escVoltageBytes = {orientationAll[32], orientationAll[33]};
            byte[] escCurrentBytes = {orientationAll[34], orientationAll[35]};
            byte[] escUsedMahBytes = {orientationAll[36], orientationAll[37]};
            byte[] escRpmBytes = {orientationAll[38], orientationAll[39]};

            byte[] bnoTempBytes = {orientationAll[40]};
            byte[] bnoCalibrationBytes = {orientationAll[41], orientationAll[42], orientationAll[43], orientationAll[44]};

            byte[] smartHeadingOffsetBytes = {orientationAll[45], orientationAll[46]};
            //

            float batteryVoltage = (float) BitConverter.ToInt16(voltageBytes) / 1000f;

            float orientationR = (float) BitConverter.ToSingle(orientationRBytes);
            float orientationI = (float) BitConverter.ToSingle(orientationJBytes);
            float orientationJ = (float) BitConverter.ToSingle(orientationKBytes);
            float orientationK = (float) BitConverter.ToSingle(orientationIBytes);
            int headingOffset = BitConverter.ToInt16(smartHeadingOffsetBytes);

            float bnoAccelerationX = (float) BitConverter.ToInt16(bnoAccelerationXBytes) / 1000f;
            float bnoAccelerationY = (float) BitConverter.ToInt16(bnoAccelerationYBytes) / 1000f;
            float bnoAccelerationZ = (float) BitConverter.ToInt16(bnoAccelerationZBytes) / 1000f;

            float lisAccelerationX = (float) BitConverter.ToInt16(lisAccelerationXBytes);
            float lisAccelerationY = (float) BitConverter.ToInt16(lisAccelerationYBytes);
            float lisAccelerationZ = (float) BitConverter.ToInt16(lisAccelerationZBytes);

            float escTemperature = (float) BitConverter.ToInt16(escTemperatureBytes);
            float escVoltage = (float) BitConverter.ToInt16(escVoltageBytes);
            float escCurrent = (float) BitConverter.ToInt16(escCurrentBytes);
            float escUsedMah = (float) BitConverter.ToInt16(escUsedMahBytes);
            float escRpm = (float) BitConverter.ToInt16(escRpmBytes);

            int bnoTemp = bnoTempBytes[0];

            int bnoCalibrationSystem = bnoCalibrationBytes[0];
            int bnoCalibrationGyro = bnoCalibrationBytes[1];
            int bnoCalibrationAccelerometer = bnoCalibrationBytes[2];
            int bnoCalibrationMagnetometer = bnoCalibrationBytes[3];

            TelemetryValues.I.BatteryVoltage = batteryVoltage;
            TelemetryValues.I.Orientatation = new Quaternion(orientationI, orientationJ, orientationK, orientationR);
            TelemetryValues.I.BnoAcceleration = new Vector3(bnoAccelerationX, bnoAccelerationY, bnoAccelerationZ);
            TelemetryValues.I.LisAcceleration = new Vector3(lisAccelerationX, lisAccelerationY, lisAccelerationZ);
            TelemetryValues.I.EscTemperature = escTemperature;
            TelemetryValues.I.EscVoltage = escVoltage;
            TelemetryValues.I.EscCurrent = escCurrent;
            TelemetryValues.I.EscUsedMah = escUsedMah;
            TelemetryValues.I.EscRpm = escRpm;
            TelemetryValues.I.BnoTemp = bnoTemp;
            TelemetryValues.I.BnoCalibrationSystem = bnoCalibrationSystem;
            TelemetryValues.I.BnoCalibrationGyro = bnoCalibrationGyro;
            TelemetryValues.I.BnoCalibrationAccelerometer = bnoCalibrationAccelerometer;
            TelemetryValues.I.BnoCalibrationMagnetometer = bnoCalibrationMagnetometer;
            TelemetryValues.I.SmartHeadingOffset = headingOffset;


        }
    }

}

// Extensions that make it easier to get a D-Bus object or read a characteristic value.
static class Extensions
{

    public static Task<IReadOnlyList<IDevice1>> GetDevicesAsync(this IAdapter1 adapter)
    {
        return GetProxiesAsync<IDevice1>(adapter, BluezConstants.Device1Interface);
    }

    public static async Task<IDevice1> GetDeviceAsync(this IAdapter1 adapter, string deviceAddress)
    {
        var devices = await GetProxiesAsync<IDevice1>(adapter, BluezConstants.Device1Interface);
        var matches = new List<IDevice1>();

        foreach (var device in devices)
        {
            if (String.Equals(await device.GetAddressAsync(), deviceAddress, StringComparison.OrdinalIgnoreCase))
            {
                matches.Add(device);
            }
        }

        // BlueZ can get in a weird state, probably due to random public BLE addresses.
        if (matches.Count > 1)
        {
            throw new Exception($"{matches.Count} devices found with the address {deviceAddress}!");
        }

        return matches.FirstOrDefault();
    }

    public static async Task<IDevice1> GetDeviceAsyncAnyByName(this IAdapter1 adapter, string deviceName)
    {
        var devices = await GetProxiesAsync<IDevice1>(adapter, BluezConstants.Device1Interface);
        var matches = new List<IDevice1>();

        foreach (var device in devices)
        {
            //if (String.Equals(await device.GetAddressAsync(), deviceAddress, StringComparison.OrdinalIgnoreCase))
            var currentDeviceAddress = await device.GetAddressAsync();
            var currentDeviceName = await device.GetNameAsync();

            if (currentDeviceName.Contains(deviceName))
            {
                matches.Add(device);
            }
        }

        // BlueZ can get in a weird state, probably due to random public BLE addresses.
        if (matches.Count > 1)
        {
            throw new Exception($"{matches.Count} devices found with the name {deviceName}! Turn some off!!!");
        }

        return matches.FirstOrDefault();
    }

    public static async Task<IGattService1> GetServiceAsync(this IDevice1 device, string serviceUUID)
    {
        var services = await GetProxiesAsync<IGattService1>(device, BluezConstants.GattServiceInterface);

        foreach (var service in services)
        {
            if (String.Equals(await service.GetUUIDAsync(), serviceUUID, StringComparison.OrdinalIgnoreCase))
            {
                return service;
            }
        }

        return null;
    }

    public static async Task<IGattCharacteristic1> GetCharacteristicAsync(this IGattService1 service, string characteristicUUID)
    {
        var characteristics = await GetProxiesAsync<IGattCharacteristic1>(service, BluezConstants.GattCharacteristicInterface);

        foreach (var characteristic in characteristics)
        {
            if (String.Equals(await characteristic.GetUUIDAsync(), characteristicUUID, StringComparison.OrdinalIgnoreCase))
            {
                return characteristic;
            }
        }

        return null;
    }

    public static async Task<byte[]> ReadValueAsync(this IGattCharacteristic1 characteristic, TimeSpan timeout)
    {
        var options = new Dictionary<string, object>();
        var readTask = characteristic.ReadValueAsync(options);
        var timeoutTask = Task.Delay(timeout);

        await Task.WhenAny(new Task[] {readTask, timeoutTask});

        if (!readTask.IsCompleted)
        {
            throw new TimeoutException("Timed out waiting to read characteristic value.");
        }

        return await readTask;
    }


    public static async Task WriteValueAsync(this IGattCharacteristic1 characteristic, byte[] newValue, TimeSpan timeout)
    {
        var options = new Dictionary<string, object>();
        var writeTask = characteristic.WriteValueAsync(newValue, options);
        var timeoutTask = Task.Delay(timeout);

        await Task.WhenAny(new Task[] {writeTask, timeoutTask});

        if (!writeTask.IsCompleted)
        {
            throw new TimeoutException("Timed out waiting to write characteristic value.");
        }

        return;
    }

    public static async Task NotifyValueAsync(this IGattCharacteristic1 characteristic, byte[] newValue, TimeSpan timeout)
    {
        var options = new Dictionary<string, object>();
        var notifyTask = characteristic.WriteValueAsync(newValue, options);
        var timeoutTask = Task.Delay(timeout);

        await Task.WhenAny(new Task[] {notifyTask, timeoutTask});

        if (!notifyTask.IsCompleted)
        {
            throw new TimeoutException("Timed out waiting to write characteristic value.");
        }

        return;
    }

    private static async Task<IReadOnlyList<T>> GetProxiesAsync<T>(IDBusObject rootObject, string interfaceName)
    {
        // Console.WriteLine("GetProxiesAsync called.");
        var objectManager = Connection.System.CreateProxy<IObjectManager>(BluezConstants.DBusService, "/");
        var objects = await objectManager.GetManagedObjectsAsync();

        var matchingObjects = objects
            .Where(obj => obj.Value.Keys.Contains(interfaceName))
            .Select(obj => obj.Key)
            .Where(objectPath => objectPath.ToString().StartsWith($"{rootObject.ObjectPath}/"));

        var proxies = matchingObjects
            .Select(objectPath => Connection.System.CreateProxy<T>(BluezConstants.DBusService, objectPath))
            .ToList();

        // Console.WriteLine($"GetProxiesAsync returning {proxies.Count} proxies of type {typeof(T)}.");
        return proxies;
    }

}


static class GattConstants
{

    // "Device Information" GATT service
    // https://www.bluetooth.org/docman/handlers/downloaddoc.ashx?doc_id=244369
    public const string DeviceInformationServiceUUID = "7ac5d0b9-a214-4c2b-b02a-7d300d756709";

    public const string CtrlAllUUID = "1d340766-ffa2-4aed-b03d-cf3796a46d82";
    public const string CtrlRUUID = "ec7e03b4-d6d8-4ad7-a1e0-0e48fe405bb8";

    public const string OrientationAllUUID = "64dc361e-9e25-4ab9-aa07-4813b15f2c83";

}


static class BluezConstants
{

    public const string DBusService = "org.bluez";
    public const string Adapter1Interface = "org.bluez.Adapter1";
    public const string Device1Interface = "org.bluez.Device1";
    public const string GattServiceInterface = "org.bluez.GattService1";
    public const string GattCharacteristicInterface = "org.bluez.GattCharacteristic1";

}