using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.UI;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
// The code generated by `dotnet dbus codegen`.
using bluez.DBus;
using PearlSoft.Scripts.Runtime.ScreenUI.OutputElements;
// See https://developers.redhat.com/blog/2017/09/18/connecting-net-core-d-bus/ or https://github.com/tmds/Tmds.DBus
using Tmds.DBus;
using Debug = UnityEngine.Debug;


public class BluetoothConsole : MonoBehaviour
{

    [SerializeField]
    private MonospaceTextLogOutput _console;

    [SerializeField]
    private Transform _rotateCube;

    [SerializeField]
    private Text _voltageText;

    private bool _sensorEnabled = true;


    private IEnumerator Start()
    {
        while (InputManager.I == null)
        {
            yield return null;
        }
        
        while (HeartbeatController.I == null)
        {
            yield return null;
        }
        
        _console.LogText("Scan Started");
        
        Scan();

        UpdateButtonText();
    }

    public void ToggleSensor()
    {
        _sensorEnabled = !_sensorEnabled;

        UpdateButtonText();
    }

    private void UpdateButtonText()
    {
    }

    public void Scan()
    {
        var adapterName = "hci0";

        var adapterObjectPath = $"/org/bluez/{adapterName}";
        var adapter = Connection.System.CreateProxy<IAdapter1>(BluezConstants.DBusService, adapterObjectPath);

        if (adapter == null)
        {
            _console.LogText(($"Adapter Missing"));
        }
        else
        {
            _console.LogText("Adapter found");
        }

        ScanAsync(adapter);

        // Find the Bluetooth peripheral.


    }

    private async void ScanAsync(IAdapter1 adapter)
    {
        var deviceAddress = "58:CF:79:F3:29:BE";
        
        var deviceFindingTest = await adapter.GetDeviceAsyncAnyByName("ERGO");
        var device = await adapter.GetDeviceAsync(deviceAddress);

        if (device == null)
        {
            _console.LogText(
                $"BLE Robot missing");
            return;
        }

        _console.LogText($"BLE Robot found");


        _console.LogText(("Connecting..."));
        await device.ConnectAsync();


        //await WaitForPropertyValueAsync<bool>("Connected", device.GetConnectedAsync(), value: true, 5);
        _console.LogText(("Connected."));


        var servicesUUID = await device.GetUUIDsAsync();
        _console.LogText(($"{servicesUUID.Length} service(s)"));

        var deviceInfoServiceFound = servicesUUID.Any(uuid => String.Equals(uuid, GattConstants.DeviceInformationServiceUUID, StringComparison.OrdinalIgnoreCase));

        if (!deviceInfoServiceFound)
        {
            _console.LogText(("Missing DIS"));
            return;
        }

        var service = await device.GetServiceAsync(GattConstants.DeviceInformationServiceUUID);

        var orientationAllCharacteristic = await service.GetCharacteristicAsync(GattConstants.OrientationAllUUID);
        var ctrlAllCharacteristic = await service.GetCharacteristicAsync(GattConstants.CtrlAllUUID);


        byte[] orientationAll;
        int characteristicsFound = 0;

        var timeout = TimeSpan.FromSeconds(5);

        if (orientationAllCharacteristic != null)
        {
            characteristicsFound++;
            _console.LogText(("Get Telemetry"));
        }

        int defaultAngle = 90;

        if (ctrlAllCharacteristic != null)
        {
            characteristicsFound++;
            _console.LogText(("Set Control"));
        }

        if (characteristicsFound == 0)
        {
            _console.LogText(("No GATTChar found"));
        }

        _console.LogText("Initialized");
        var taskS = JoystickTask(ctrlAllCharacteristic);
        var taskAll = SensorAllTask(orientationAllCharacteristic);
        await Task.WhenAll(taskS, taskAll);


    }

    private async Task JoystickTask(IGattCharacteristic1 characteristicAll)
    {
        var timeout = TimeSpan.FromSeconds(5);
        short lValue;
        short rValue;

        while (Application.isPlaying)
        {
            short safetyOffset = 0;

            const short amountToThrottle = 30;
            const short forwardAngle = 90 + amountToThrottle;
            const short reverseAngle = 90 - amountToThrottle;

            if (InputManager.I.DPadUpPressed)
            {
                lValue = forwardAngle;
                rValue = forwardAngle;
            }
            else if (InputManager.I.DPadDownPressed)
            {
                lValue = reverseAngle;
                rValue = reverseAngle;
            }
            else if (InputManager.I.DPadLeftPressed)
            {
                lValue = reverseAngle;
                rValue = forwardAngle;
            }
            else if (InputManager.I.DPadRightPressed)
            {
                lValue = forwardAngle;
                rValue = reverseAngle;
            }
            else
            {
                lValue = (short) ((short) (InputManager.I.LY * -90f + 90f));
                rValue = (short) ((short) (InputManager.I.RY * -90f + 90f));

            }

            short w0Value = (short) ((short) (InputManager.I.L2 * -90f + 90f));
            short w1Value = (short) ((short) (InputManager.I.R2 * -90f + 90f));

            TelemetryValues.I.WeaponThrottle = w1Value;
            
            short driveThrottle = (short)(-InputManager.I.LY * 100);

            short SecurityBytes = 0x69;

            short placeholderBytes = 0x00;

            List<byte> ctrlValueList = new List<byte>();
            ctrlValueList.AddRange(BitConverter.GetBytes(SecurityBytes)); //0-1
            ctrlValueList.AddRange(BitConverter.GetBytes(InputManager.I.ButtonBytes)); //2-3
            ctrlValueList.AddRange(BitConverter.GetBytes(InputManager.I.Heading)); //4-5
            ctrlValueList.AddRange(BitConverter.GetBytes(driveThrottle)); //6-7
            ctrlValueList.AddRange(BitConverter.GetBytes(lValue));//8-9
            ctrlValueList.AddRange(BitConverter.GetBytes(rValue)); //10-11
            ctrlValueList.AddRange(BitConverter.GetBytes(w0Value)); //12-13
            ctrlValueList.AddRange(BitConverter.GetBytes(w1Value)); //14-15
            //ctrlValueList.AddRange(BitConverter.GetBytes(placeholderBytes)); //16
            //ctrlValueList.AddRange(BitConverter.GetBytes(placeholderBytes)); //18
            
            ctrlValueList.Add(SoftValuesManager.NormalizedFloatToByte(SoftValuesManager.I.AngleToleranceNormalized)); //16
            ctrlValueList.Add(SoftValuesManager.NormalizedFloatToByte(SoftValuesManager.I.TurningMultiplierNormalized)); //17
            ctrlValueList.Add(SoftValuesManager.NormalizedFloatToByte(SoftValuesManager.I.AdditiveThrottleMultiplerNormalized)); //18
            ctrlValueList.Add(SoftValuesManager.NormalizedFloatToByte(SoftValuesManager.I.MaxWeaponThrottleNormalized)); //19


            
            
            ctrlValueList.AddRange(BitConverter.GetBytes(placeholderBytes)); //20
            ctrlValueList.AddRange(BitConverter.GetBytes(placeholderBytes)); //22
            ctrlValueList.AddRange(BitConverter.GetBytes(placeholderBytes)); //24
            ctrlValueList.AddRange(BitConverter.GetBytes(placeholderBytes)); //26
            ctrlValueList.AddRange(BitConverter.GetBytes(placeholderBytes)); //28
            ctrlValueList.AddRange(BitConverter.GetBytes(placeholderBytes)); //30
            ctrlValueList.AddRange(BitConverter.GetBytes(HeartbeatController.I.HeartbeatTime)); // 32-35
            ctrlValueList.AddRange(BitConverter.GetBytes(SecurityBytes)); //36-37
            
            byte[] ctrlValue = ctrlValueList.ToArray();


            var writeAll = characteristicAll.WriteValueAsync(ctrlValue, timeout);

            await Task.WhenAll(writeAll);

            //Debug.LogError($"joystick task {Time.time:0.000}");
        }
    }

    private async Task SensorAllTask(IGattCharacteristic1 characteristicAll)
    {
        var timeout = TimeSpan.FromSeconds(5);

        while (Application.isPlaying)
        {

            //Debug.LogError($"sensor task {Time.time:0.000}");


            byte[] orientationAll;
            orientationAll = await characteristicAll.ReadValueAsync(timeout);

            byte[] voltageBytes = {orientationAll[0], orientationAll[1]};

            byte[] orientationRBytes = {orientationAll[2], orientationAll[3], orientationAll[4], orientationAll[5]};
            byte[] orientationIBytes = {orientationAll[6], orientationAll[7], orientationAll[8], orientationAll[9]};
            byte[] orientationJBytes = {orientationAll[10], orientationAll[11], orientationAll[12], orientationAll[13]};
            byte[] orientationKBytes = {orientationAll[14], orientationAll[15], orientationAll[16], orientationAll[17]};

            byte[] bnoAccelerationXBytes = {orientationAll[18], orientationAll[19]};
            byte[] bnoAccelerationYBytes = {orientationAll[20], orientationAll[21]};
            byte[] bnoAccelerationZBytes = {orientationAll[22], orientationAll[23]};

            byte[] lisAccelerationXBytes = {orientationAll[24], orientationAll[25]};
            byte[] lisAccelerationYBytes = {orientationAll[26], orientationAll[27]};
            byte[] lisAccelerationZBytes = {orientationAll[28], orientationAll[29]};

            byte[] escTemperatureBytes = {orientationAll[30], orientationAll[31]};
            byte[] escVoltageBytes = {orientationAll[32], orientationAll[33]};
            byte[] escCurrentBytes = {orientationAll[34], orientationAll[35]};
            byte[] escUsedMahBytes = {orientationAll[36], orientationAll[37]};
            byte[] escRpmBytes = {orientationAll[38], orientationAll[39]};
            
            byte[] bnoTempBytes = {orientationAll[40]};
            byte[] bnoCalibrationBytes = {orientationAll[41], orientationAll[42], orientationAll[43], orientationAll[44]};

            byte[] smartHeadingOffsetBytes = {orientationAll[45], orientationAll[46]};
            //

            float batteryVoltage = (float) BitConverter.ToInt16(voltageBytes) / 1000f;

            float orientationR = (float) BitConverter.ToSingle(orientationRBytes);
            float orientationI = (float) BitConverter.ToSingle(orientationJBytes);
            float orientationJ = (float) BitConverter.ToSingle(orientationKBytes);
            float orientationK = (float) BitConverter.ToSingle(orientationIBytes);
            int headingOffset = BitConverter.ToInt16(smartHeadingOffsetBytes);

            float bnoAccelerationX = (float) BitConverter.ToInt16(bnoAccelerationXBytes) / 1000f;
            float bnoAccelerationY = (float) BitConverter.ToInt16(bnoAccelerationYBytes) / 1000f;
            float bnoAccelerationZ = (float) BitConverter.ToInt16(bnoAccelerationZBytes) / 1000f;

            float lisAccelerationX = (float) BitConverter.ToInt16(lisAccelerationXBytes);
            float lisAccelerationY = (float) BitConverter.ToInt16(lisAccelerationYBytes);
            float lisAccelerationZ = (float) BitConverter.ToInt16(lisAccelerationZBytes);

            float escTemperature = (float) BitConverter.ToInt16(escTemperatureBytes);
            float escVoltage = (float) BitConverter.ToInt16(escVoltageBytes);
            float escCurrent = (float) BitConverter.ToInt16(escCurrentBytes);
            float escUsedMah = (float) BitConverter.ToInt16(escUsedMahBytes);
            float escRpm = (float) BitConverter.ToInt16(escRpmBytes);

            int bnoTemp = bnoTempBytes[0];

            int bnoCalibrationSystem = bnoCalibrationBytes[0];
            int bnoCalibrationGyro = bnoCalibrationBytes[1];
            int bnoCalibrationAccelerometer = bnoCalibrationBytes[2];
            int bnoCalibrationMagnetometer = bnoCalibrationBytes[3];

            TelemetryValues.I.BatteryVoltage = batteryVoltage;
            TelemetryValues.I.Orientatation = new Quaternion(orientationI, orientationJ, orientationK, orientationR);
            TelemetryValues.I.BnoAcceleration = new Vector3(bnoAccelerationX, bnoAccelerationY, bnoAccelerationZ);
            TelemetryValues.I.LisAcceleration = new Vector3(lisAccelerationX, lisAccelerationY, lisAccelerationZ);
            TelemetryValues.I.EscTemperature = escTemperature;
            TelemetryValues.I.EscVoltage = escVoltage;
            TelemetryValues.I.EscCurrent = escCurrent;
            TelemetryValues.I.EscUsedMah = escUsedMah;
            TelemetryValues.I.EscRpm = escRpm;
            TelemetryValues.I.BnoTemp = bnoTemp;
            TelemetryValues.I.BnoCalibrationSystem = bnoCalibrationSystem;
            TelemetryValues.I.BnoCalibrationGyro = bnoCalibrationGyro;
            TelemetryValues.I.BnoCalibrationAccelerometer = bnoCalibrationAccelerometer;
            TelemetryValues.I.BnoCalibrationMagnetometer = bnoCalibrationMagnetometer;
            TelemetryValues.I.SmartHeadingOffset = headingOffset;


        }
    }

}

/*

// Use the `bluetoothctl` command-line tool or the Bluetooth Manager GUI to scan for devices and possibly pair.
// Then you can use this program to connect and print "Device Information" GATT service values.
class Program
{
  static string defaultAdapterName = "hci0";
  static TimeSpan timeout = TimeSpan.FromSeconds(15);

  static async Task Main(string[] args)
  {
    if (args.Length < 1)
    {
      Console.WriteLine("Usage: BlueZExample <deviceAddress> [adapterName]");
      Console.WriteLine("Example: BlueZExample AA:BB:CC:11:22:33 hci1");
      return;
    }

    var deviceAddress = args[0];
    var adapterName = args.Length > 1 ? args[1] : defaultAdapterName;

    // Get the Bluetooth adapter.
    var adapterObjectPath = $"/org/bluez/{adapterName}";
    var adapter = Connection.System.CreateProxy<IAdapter1>(BluezConstants.DBusService, adapterObjectPath);
    if (adapter == null)
    {
      Console.WriteLine($"Bluetooth adapter '{adapterName}' not found.");
    }

    // Find the Bluetooth peripheral.
    var device = await adapter.GetDeviceAsync(deviceAddress);
    if (device == null)
    {
      Console.WriteLine($"Bluetooth peripheral with address '{deviceAddress}' not found. Use `bluetoothctl` or Bluetooth Manager to scan and possibly pair first.");
      return;
    }

    Console.WriteLine("Connecting...");
    await device.ConnectAsync();
    await WaitForPropertyValueAsync<bool>("Connected", device.GetConnectedAsync, value: true, timeout);
    Console.WriteLine("Connected.");

    Console.WriteLine("Waiting for services to resolve...");
    await WaitForPropertyValueAsync<bool>("ServicesResolved", device.GetServicesResolvedAsync, value: true, timeout);

    var servicesUUID = await device.GetUUIDsAsync();
    Console.WriteLine($"Device offers {servicesUUID.Length} service(s).");

    var deviceInfoServiceFound = servicesUUID.Any(uuid => String.Equals(uuid, GattConstants.DeviceInformationServiceUUID, StringComparison.OrdinalIgnoreCase));
    if (!deviceInfoServiceFound)
    {
      Console.WriteLine("Device doesn't have the Device Information Service. Try pairing first?");
      return;
    }

    // Console.WriteLine("Retrieving Device Information service...");
    var service = await device.GetServiceAsync(GattConstants.DeviceInformationServiceUUID);
    var modelNameCharacteristic = await service.GetCharacteristicAsync(GattConstants.ModelNameCharacteristicUUID);
    var manufacturerCharacteristic = await service.GetCharacteristicAsync(GattConstants.ManufacturerNameCharacteristicUUID);

    int characteristicsFound = 0;
    if (modelNameCharacteristic != null)
    {
        characteristicsFound++;
        Console.WriteLine("Reading model name characteristic...");
        var modelNameBytes = await modelNameCharacteristic.ReadValueAsync(timeout);
        Console.WriteLine($"Model name: {Encoding.UTF8.GetString(modelNameBytes)}");
    }

    if (manufacturerCharacteristic != null)
    {
        characteristicsFound++;
        Console.WriteLine("Reading manufacturer characteristic...");
        var manufacturerBytes = await manufacturerCharacteristic.ReadValueAsync(timeout);
        Console.WriteLine($"Manufacturer: {Encoding.UTF8.GetString(manufacturerBytes)}");
    }

    if (characteristicsFound == 0)
    {
        Console.WriteLine("Model name and manufacturer characteristics not found.");
    }
  }


*/


// Extensions that make it easier to get a D-Bus object or read a characteristic value.
static class Extensions
{

    public static Task<IReadOnlyList<IDevice1>> GetDevicesAsync(this IAdapter1 adapter)
    {
        return GetProxiesAsync<IDevice1>(adapter, BluezConstants.Device1Interface);
    }

    public static async Task<IDevice1> GetDeviceAsync(this IAdapter1 adapter, string deviceAddress)
    {
        var devices = await GetProxiesAsync<IDevice1>(adapter, BluezConstants.Device1Interface);
        var matches = new List<IDevice1>();

        foreach (var device in devices)
        {
            if (String.Equals(await device.GetAddressAsync(), deviceAddress, StringComparison.OrdinalIgnoreCase))
            {
                matches.Add(device);
            }
        }

        // BlueZ can get in a weird state, probably due to random public BLE addresses.
        if (matches.Count > 1)
        {
            throw new Exception($"{matches.Count} devices found with the address {deviceAddress}!");
        }

        return matches.FirstOrDefault();
    }
    
    public static async Task<IDevice1> GetDeviceAsyncAnyByName(this IAdapter1 adapter, string deviceName)
    {
        var devices = await GetProxiesAsync<IDevice1>(adapter, BluezConstants.Device1Interface);
        var matches = new List<IDevice1>();

        foreach (var device in devices)
        {
            //if (String.Equals(await device.GetAddressAsync(), deviceAddress, StringComparison.OrdinalIgnoreCase))
            var currentDeviceName = await device.GetNameAsync();
            Debug.LogError($"currentDeviceName: {currentDeviceName}");
            if(currentDeviceName.Contains(deviceName))
            {
                matches.Add(device);
            }
        }

        // BlueZ can get in a weird state, probably due to random public BLE addresses.
        if (matches.Count > 1)
        {
            throw new Exception($"{matches.Count} devices found with the name {deviceName}! Turn some off!!!");
        }

        return matches.FirstOrDefault();
    }

    public static async Task<IGattService1> GetServiceAsync(this IDevice1 device, string serviceUUID)
    {
        var services = await GetProxiesAsync<IGattService1>(device, BluezConstants.GattServiceInterface);

        foreach (var service in services)
        {
            if (String.Equals(await service.GetUUIDAsync(), serviceUUID, StringComparison.OrdinalIgnoreCase))
            {
                return service;
            }
        }

        return null;
    }

    public static async Task<IGattCharacteristic1> GetCharacteristicAsync(this IGattService1 service, string characteristicUUID)
    {
        var characteristics = await GetProxiesAsync<IGattCharacteristic1>(service, BluezConstants.GattCharacteristicInterface);

        foreach (var characteristic in characteristics)
        {
            if (String.Equals(await characteristic.GetUUIDAsync(), characteristicUUID, StringComparison.OrdinalIgnoreCase))
            {
                return characteristic;
            }
        }

        return null;
    }

    public static async Task<byte[]> ReadValueAsync(this IGattCharacteristic1 characteristic, TimeSpan timeout)
    {
        var options = new Dictionary<string, object>();
        var readTask = characteristic.ReadValueAsync(options);
        var timeoutTask = Task.Delay(timeout);

        await Task.WhenAny(new Task[] {readTask, timeoutTask});

        if (!readTask.IsCompleted)
        {
            throw new TimeoutException("Timed out waiting to read characteristic value.");
        }

        return await readTask;
    }


    public static async Task WriteValueAsync(this IGattCharacteristic1 characteristic, byte[] newValue, TimeSpan timeout)
    {
        var options = new Dictionary<string, object>();
        var writeTask = characteristic.WriteValueAsync(newValue, options);
        var timeoutTask = Task.Delay(timeout);

        await Task.WhenAny(new Task[] {writeTask, timeoutTask});

        if (!writeTask.IsCompleted)
        {
            throw new TimeoutException("Timed out waiting to write characteristic value.");
        }

        return;
    }

    public static async Task NotifyValueAsync(this IGattCharacteristic1 characteristic, byte[] newValue, TimeSpan timeout)
    {
        var options = new Dictionary<string, object>();
        var notifyTask = characteristic.WriteValueAsync(newValue, options);
        var timeoutTask = Task.Delay(timeout);

        await Task.WhenAny(new Task[] {notifyTask, timeoutTask});

        if (!notifyTask.IsCompleted)
        {
            throw new TimeoutException("Timed out waiting to write characteristic value.");
        }

        return;
    }

    private static async Task<IReadOnlyList<T>> GetProxiesAsync<T>(IDBusObject rootObject, string interfaceName)
    {
        // Console.WriteLine("GetProxiesAsync called.");
        var objectManager = Connection.System.CreateProxy<IObjectManager>(BluezConstants.DBusService, "/");
        var objects = await objectManager.GetManagedObjectsAsync();

        var matchingObjects = objects
            .Where(obj => obj.Value.Keys.Contains(interfaceName))
            .Select(obj => obj.Key)
            .Where(objectPath => objectPath.ToString().StartsWith($"{rootObject.ObjectPath}/"));

        var proxies = matchingObjects
            .Select(objectPath => Connection.System.CreateProxy<T>(BluezConstants.DBusService, objectPath))
            .ToList();

        // Console.WriteLine($"GetProxiesAsync returning {proxies.Count} proxies of type {typeof(T)}.");
        return proxies;
    }

}


static class GattConstants
{

    // "Device Information" GATT service
    // https://www.bluetooth.org/docman/handlers/downloaddoc.ashx?doc_id=244369
    public const string DeviceInformationServiceUUID = "7ac5d0b9-a214-4c2b-b02a-7d300d756709";

    public const string CtrlAllUUID = "1d340766-ffa2-4aed-b03d-cf3796a46d82";
    public const string CtrlRUUID = "ec7e03b4-d6d8-4ad7-a1e0-0e48fe405bb8";

    public const string OrientationAllUUID = "64dc361e-9e25-4ab9-aa07-4813b15f2c83";

}


static class BluezConstants
{

    public const string DBusService = "org.bluez";
    public const string Adapter1Interface = "org.bluez.Adapter1";
    public const string Device1Interface = "org.bluez.Device1";
    public const string GattServiceInterface = "org.bluez.GattService1";
    public const string GattCharacteristicInterface = "org.bluez.GattCharacteristic1";

}