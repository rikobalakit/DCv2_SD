using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.UI;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
// The code generated by `dotnet dbus codegen`.
using bluez.DBus;
// See https://developers.redhat.com/blog/2017/09/18/connecting-net-core-d-bus/ or https://github.com/tmds/Tmds.DBus
using Tmds.DBus;

// The code generated by `dotnet dbus codegen`.
using bluez.DBus;
// See https://developers.redhat.com/blog/2017/09/18/connecting-net-core-d-bus/ or https://github.com/tmds/Tmds.DBus
using Tmds.DBus;
using Debug = UnityEngine.Debug;


public class BluetoothConsole : MonoBehaviour
{

    [SerializeField]
    private Text _console;

    private Vector3 _currentOrientation;

    [SerializeField]
    private Transform _rotateCube;
    
    private void Start()
    {
        _console.text += "\n" + "Initialized";
    }

    private void Update()
    {
        _rotateCube.localRotation =  Quaternion.Slerp(_rotateCube.localRotation, Quaternion.Euler(_currentOrientation), Time.deltaTime * 10f);
    }


    public void Scan()
    {
        _console.text += "\n" + "Not implemented";

        var adapterName = "hci0";

        var adapterObjectPath = $"/org/bluez/{adapterName}";
        var adapter = Connection.System.CreateProxy<IAdapter1>(BluezConstants.DBusService, adapterObjectPath);

        if (adapter == null)
        {
            _console.text += "\n" + ($"Bluetooth adapter '{adapterName}' not found.");
        }
        else
        {
            _console.text += "\n" + "Adapter found";
        }

        ScanAsync(adapter);

        // Find the Bluetooth peripheral.


    }

    private async void ScanAsync(IAdapter1 adapter)
    {
        var deviceAddress = "84:F7:03:A9:7D:76";


        var device = await adapter.GetDeviceAsync(deviceAddress);

        if (device == null)
        {
            _console.text += "\n" +
                $"Bluetooth peripheral with address '{deviceAddress}' not found. Use `bluetoothctl` or Bluetooth Manager to scan and possibly pair first.";
            return;
        }

        _console.text += "\n" + $"Found robot named {await device.GetNameAsync()}";


        _console.text += "\n" + ("Connecting...");
        await device.ConnectAsync();


        //await WaitForPropertyValueAsync<bool>("Connected", device.GetConnectedAsync(), value: true, 5);
        _console.text += "\n" + ("Connected.");


        var servicesUUID = await device.GetUUIDsAsync();
        _console.text += "\n" + ($"Device offers {servicesUUID.Length} service(s).");

        var deviceInfoServiceFound = servicesUUID.Any(uuid => String.Equals(uuid, GattConstants.DeviceInformationServiceUUID, StringComparison.OrdinalIgnoreCase));

        if (!deviceInfoServiceFound)
        {
            _console.text += "\n" + ("Device doesn't have the Device Information Service. Try pairing first?");
            return;
        }

        // _console.text += "\n"+("Retrieving Device Information service...");
        var service = await device.GetServiceAsync(GattConstants.DeviceInformationServiceUUID);
        var orientationXCharacteristic = await service.GetCharacteristicAsync(GattConstants.OrientationXUUID);

        var orientationYCharacteristic = await service.GetCharacteristicAsync(GattConstants.OrientationYUUID);

        var orientationZCharacteristic = await service.GetCharacteristicAsync(GattConstants.OrientationZUUID);
        var ctrlCharacteristic = await service.GetCharacteristicAsync(GattConstants.CtrlUUID);

        byte[] orientationX, orientationY, orientationZ;
        var timeout = TimeSpan.FromSeconds(5);
        int characteristicsFound = 0;

        if (orientationXCharacteristic != null)
        {
            characteristicsFound++;
            _console.text += "\n" + ("Reading orientationXCharacteristic...");
            orientationX = await orientationXCharacteristic.ReadValueAsync(timeout);
            _console.text += "\n" + ($"orientationXCharacteristic: {Encoding.UTF8.GetString(orientationX)}");
        }

        if (orientationYCharacteristic != null)
        {
            characteristicsFound++;
            _console.text += "\n" + ("Reading orientationYCharacteristic...");
            orientationY = await orientationYCharacteristic.ReadValueAsync(timeout);
            _console.text += "\n" + ($"orientationYCharacteristic: {Encoding.UTF8.GetString(orientationY)}");
        }


        if (orientationZCharacteristic != null)
        {
            characteristicsFound++;
            _console.text += "\n" + ("Reading orientationZCharacteristic...");
            orientationZ = await orientationZCharacteristic.ReadValueAsync(timeout);
            _console.text += "\n" + ($"orientationZCharacteristic: {Encoding.UTF8.GetString(orientationZ)}");
        }


        if (ctrlCharacteristic != null)
        {
            characteristicsFound++;
            _console.text += "\n" + ("Reading ctrlCharacteristic...");
            var manufacturerBytes = await ctrlCharacteristic.ReadValueAsync(timeout);
            _console.text += "\n" + ($"ctrlCharacteristic: {Encoding.UTF8.GetString(manufacturerBytes)}");

            await ctrlCharacteristic.WriteValueAsync(Encoding.UTF8.GetBytes("180"), timeout);
        }


        if (characteristicsFound == 0)
        {
            _console.text += "\n" + ("Model name and manufacturer characteristics not found.");
        }

        while (true)
        {
            orientationX = await orientationXCharacteristic.ReadValueAsync(timeout);
            orientationY = await orientationYCharacteristic.ReadValueAsync(timeout);
            orientationZ = await orientationZCharacteristic.ReadValueAsync(timeout);
            
            await ctrlCharacteristic.WriteValueAsync(Encoding.UTF8.GetBytes($"{Input.GetAxis("RY") * 90f + 90f}"), timeout);
            //ctrlCharacteristic.WriteValueAsync(Encoding.UTF8.GetBytes("180"), timeout);


            _currentOrientation = new Vector3(float.Parse(Encoding.UTF8.GetString(orientationX)),
                float.Parse(Encoding.UTF8.GetString(orientationY)),
                float.Parse(Encoding.UTF8.GetString(orientationZ)));

            //Debug.LogError($"orientation: ({Encoding.UTF8.GetString(orientationX):0.0}, {Encoding.UTF8.GetString(orientationY):0.0}, {Encoding.UTF8.GetString(orientationZ):0.0})");
        }

    }

}

/*

// Use the `bluetoothctl` command-line tool or the Bluetooth Manager GUI to scan for devices and possibly pair.
// Then you can use this program to connect and print "Device Information" GATT service values.
class Program
{
  static string defaultAdapterName = "hci0";
  static TimeSpan timeout = TimeSpan.FromSeconds(15);

  static async Task Main(string[] args)
  {
    if (args.Length < 1)
    {
      Console.WriteLine("Usage: BlueZExample <deviceAddress> [adapterName]");
      Console.WriteLine("Example: BlueZExample AA:BB:CC:11:22:33 hci1");
      return;
    }

    var deviceAddress = args[0];
    var adapterName = args.Length > 1 ? args[1] : defaultAdapterName;

    // Get the Bluetooth adapter.
    var adapterObjectPath = $"/org/bluez/{adapterName}";
    var adapter = Connection.System.CreateProxy<IAdapter1>(BluezConstants.DBusService, adapterObjectPath);
    if (adapter == null)
    {
      Console.WriteLine($"Bluetooth adapter '{adapterName}' not found.");
    }

    // Find the Bluetooth peripheral.
    var device = await adapter.GetDeviceAsync(deviceAddress);
    if (device == null)
    {
      Console.WriteLine($"Bluetooth peripheral with address '{deviceAddress}' not found. Use `bluetoothctl` or Bluetooth Manager to scan and possibly pair first.");
      return;
    }

    Console.WriteLine("Connecting...");
    await device.ConnectAsync();
    await WaitForPropertyValueAsync<bool>("Connected", device.GetConnectedAsync, value: true, timeout);
    Console.WriteLine("Connected.");

    Console.WriteLine("Waiting for services to resolve...");
    await WaitForPropertyValueAsync<bool>("ServicesResolved", device.GetServicesResolvedAsync, value: true, timeout);

    var servicesUUID = await device.GetUUIDsAsync();
    Console.WriteLine($"Device offers {servicesUUID.Length} service(s).");

    var deviceInfoServiceFound = servicesUUID.Any(uuid => String.Equals(uuid, GattConstants.DeviceInformationServiceUUID, StringComparison.OrdinalIgnoreCase));
    if (!deviceInfoServiceFound)
    {
      Console.WriteLine("Device doesn't have the Device Information Service. Try pairing first?");
      return;
    }

    // Console.WriteLine("Retrieving Device Information service...");
    var service = await device.GetServiceAsync(GattConstants.DeviceInformationServiceUUID);
    var modelNameCharacteristic = await service.GetCharacteristicAsync(GattConstants.ModelNameCharacteristicUUID);
    var manufacturerCharacteristic = await service.GetCharacteristicAsync(GattConstants.ManufacturerNameCharacteristicUUID);

    int characteristicsFound = 0;
    if (modelNameCharacteristic != null)
    {
        characteristicsFound++;
        Console.WriteLine("Reading model name characteristic...");
        var modelNameBytes = await modelNameCharacteristic.ReadValueAsync(timeout);
        Console.WriteLine($"Model name: {Encoding.UTF8.GetString(modelNameBytes)}");
    }

    if (manufacturerCharacteristic != null)
    {
        characteristicsFound++;
        Console.WriteLine("Reading manufacturer characteristic...");
        var manufacturerBytes = await manufacturerCharacteristic.ReadValueAsync(timeout);
        Console.WriteLine($"Manufacturer: {Encoding.UTF8.GetString(manufacturerBytes)}");
    }

    if (characteristicsFound == 0)
    {
        Console.WriteLine("Model name and manufacturer characteristics not found.");
    }
  }


*/


// Extensions that make it easier to get a D-Bus object or read a characteristic value.
static class Extensions
{

    public static Task<IReadOnlyList<IDevice1>> GetDevicesAsync(this IAdapter1 adapter)
    {
        return GetProxiesAsync<IDevice1>(adapter, BluezConstants.Device1Interface);
    }

    public static async Task<IDevice1> GetDeviceAsync(this IAdapter1 adapter, string deviceAddress)
    {
        var devices = await GetProxiesAsync<IDevice1>(adapter, BluezConstants.Device1Interface);
        var matches = new List<IDevice1>();

        foreach (var device in devices)
        {
            if (String.Equals(await device.GetAddressAsync(), deviceAddress, StringComparison.OrdinalIgnoreCase))
            {
                matches.Add(device);
            }
        }

        // BlueZ can get in a weird state, probably due to random public BLE addresses.
        if (matches.Count > 1)
        {
            throw new Exception($"{matches.Count} devices found with the address {deviceAddress}!");
        }

        return matches.FirstOrDefault();
    }

    public static async Task<IGattService1> GetServiceAsync(this IDevice1 device, string serviceUUID)
    {
        var services = await GetProxiesAsync<IGattService1>(device, BluezConstants.GattServiceInterface);

        foreach (var service in services)
        {
            if (String.Equals(await service.GetUUIDAsync(), serviceUUID, StringComparison.OrdinalIgnoreCase))
            {
                return service;
            }
        }

        return null;
    }

    public static async Task<IGattCharacteristic1> GetCharacteristicAsync(this IGattService1 service, string characteristicUUID)
    {
        var characteristics = await GetProxiesAsync<IGattCharacteristic1>(service, BluezConstants.GattCharacteristicInterface);

        foreach (var characteristic in characteristics)
        {
            if (String.Equals(await characteristic.GetUUIDAsync(), characteristicUUID, StringComparison.OrdinalIgnoreCase))
            {
                return characteristic;
            }
        }

        return null;
    }

    public static async Task<byte[]> ReadValueAsync(this IGattCharacteristic1 characteristic, TimeSpan timeout)
    {
        var options = new Dictionary<string, object>();
        var readTask = characteristic.ReadValueAsync(options);
        var timeoutTask = Task.Delay(timeout);

        await Task.WhenAny(new Task[] {readTask, timeoutTask});

        if (!readTask.IsCompleted)
        {
            throw new TimeoutException("Timed out waiting to read characteristic value.");
        }

        return await readTask;
    }


    public static async Task WriteValueAsync(this IGattCharacteristic1 characteristic, byte[] newValue, TimeSpan timeout)
    {
        var options = new Dictionary<string, object>();
        var writeTask = characteristic.WriteValueAsync(newValue, options);
        var timeoutTask = Task.Delay(timeout);

        await Task.WhenAny(new Task[] {writeTask, timeoutTask});

        if (!writeTask.IsCompleted)
        {
            throw new TimeoutException("Timed out waiting to read characteristic value.");
        }

        return;
    }

    private static async Task<IReadOnlyList<T>> GetProxiesAsync<T>(IDBusObject rootObject, string interfaceName)
    {
        // Console.WriteLine("GetProxiesAsync called.");
        var objectManager = Connection.System.CreateProxy<IObjectManager>(BluezConstants.DBusService, "/");
        var objects = await objectManager.GetManagedObjectsAsync();

        var matchingObjects = objects
            .Where(obj => obj.Value.Keys.Contains(interfaceName))
            .Select(obj => obj.Key)
            .Where(objectPath => objectPath.ToString().StartsWith($"{rootObject.ObjectPath}/"));

        var proxies = matchingObjects
            .Select(objectPath => Connection.System.CreateProxy<T>(BluezConstants.DBusService, objectPath))
            .ToList();

        // Console.WriteLine($"GetProxiesAsync returning {proxies.Count} proxies of type {typeof(T)}.");
        return proxies;
    }

}


static class GattConstants
{

    // "Device Information" GATT service
    // https://www.bluetooth.org/docman/handlers/downloaddoc.ashx?doc_id=244369
    public const string DeviceInformationServiceUUID = "7ac5d0b9-a214-4c2b-b02a-7d300d756709";
    public const string ModelNameCharacteristicUUID = "00002a24-0000-1000-8000-00805f9b34fb";
    public const string ManufacturerNameCharacteristicUUID = "00002a29-0000-1000-8000-00805f9b34fb";
    public const string OrientationXUUID = "f73d52bf-8891-4b29-9dfd-a0d15bb97dde";
    public const string OrientationYUUID = "0deca531-882b-4d28-98a7-8f906aaddc10";

    public const string OrientationZUUID = "07e30a15-9505-4e3e-b9cd-3bd36b29d148";

    public const string CtrlUUID = "1d340766-ffa2-4aed-b03d-cf3796a46d82";

}


static class BluezConstants
{

    public const string DBusService = "org.bluez";
    public const string Adapter1Interface = "org.bluez.Adapter1";
    public const string Device1Interface = "org.bluez.Device1";
    public const string GattServiceInterface = "org.bluez.GattService1";
    public const string GattCharacteristicInterface = "org.bluez.GattCharacteristic1";

}